###ArrayList.

Как уже видно из названия в основе реализации этого класса лежит массив. Но при этом ArrayList позволяет справиться с самой важной проблемой массивов – неизменяемость размера массива. Это значит, что ArrayList может менять свой размер во время исполнения программы и при этом нет строгого требования указывать размерность при создании объекта ArrayList. Подчеркнем еще несколько особенностей:
- ArrayList может хранить элементы абсолютно любых типов;
- ArrayList может хранить значения null;
- ArrayList допускает хранение дубликатов.

Для создания экземпляра ArrayList в классе определено три конструктора:
1. *ArrayList ()* - создается пустой список с начальной емкостью 10 элементов.
2. *ArrayList(Collection<? extends E> col)* - создается список, в который помещается коллекция col.
3. *ArrayList(int initialCapacity)* - создается список с емкостью initialCapacity.

#### Поля
1. *transient Object[] elementData;* - хранение элементов в классе
2. *private int size;* - поле для подсчета количества элементов в коллекции

Именно с этими полями связаны все проверки по расширению массива для хранения элементов при добавлении новых элементов в список.

#### Добавление элемента в конец списка

    public boolean add(E e) {
        modCount++;
        add(e, elementData, size);
        return true;
    }

    private void add(E e, Object[] elementData, int s) {
        if (s == elementData.length)
        elementData = grow();
        elementData[s] = e;
        size = s + 1;
    }
Подробно разбирать метод grow() мы не будем, обратим лишь на самый важный момент в нем, это следующая строка:

    return elementData = Arrays.copyOf(elementData, newCapacity);
Внутри метода copyOf() происходит "тяжелая" операция по перекопированию значений из старого массива в новый. 
Именно с этим связана рекомендация о использовании конструктора со значением int initialCapacity, 
если нам конечно заранее известно сколько элементов будет храниться в нашем списке.

    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));

#### Добавления элемента в середину списка, т.е. по индексу:

1. Проверяется равенство счетчика size и длины массива elementData - если они равны происходит расширение массива, 
   за это отвечает приватный метод grow()

2. Для нового элемента подготавливается место, для этого используется метод System.arraycopy(),
   все элементы в массиве сдвигаются на одну ячейку вправо.

3. В ячейке с указанным индексом происходит перезаписывание значения и инкремент счетчика size. 
   Т.е. при однократном вызове метода добавления элемента по индексу мы можем столкнуться с ситуацией, 
   когда System.arraycopy() будет вызван дважды, а это влияет на скорость выполнения всей операции добавления.

#### Удаление по индексу

1. Определяется новый размер массива и сравнивается с индексом по которому мы удаляем:
2. Если выполняется условие из пункта 1 - происходит перекопирование элементов со сдвигом всех элементов 
   после переданного индекса на одну ячейку влево:
3. Последнее действие - нам нужно 'забыть' про последний элемент - для этого мы присваиваем ему значение null:

**Удаление элемента по значению** происходит аналогичным образом, за единственным исключением - 
перед удалением в цикле перебираются все элементы в списке, до тех пор пока не будет найдено соответствие. 
Поиск определяет индекс и дальше будет вызван метод удаления элемента по индексу. При этом удаляется только первый найденный элемент.

**Важно!** Число элементов или размер ArrayList (то, что возвращает list.size()) это количество элементов в нем, а не размер массива. 
В английской терминологии можно встретить термины capacity и size, первый описывает длину массива (array.length) 
или вместимость контейнера (а не списка, список динамический!), второй количество элементов в списке.

**Важно!** Это замечание следует из предыдущего и из свойства списков хранить null. 
В контексте ArrayList, есть null элементы (это null элементы которые мы добавляем в список) и пустые ячейки контейнера, 
которые в конечном счете, тоже null. Не путайте null элементы и пустые ячейки контейнера! 
Пример, вы создали ArrayList начальной вместимостью 10, добавили в него 5 null элементов, несмотря на то, 
что внутри ArraList массив пуст (все ячейки null), у нас есть 5 null элементов, и в этой ситуации размер списка 5. 
Все это идет из того, что при вызове метода добавления происходит увеличение счетчика, отвечающего за количество элементов.

Согласно изложенному выше, мы можем сделать некоторые выводы по ArrayList:

- быстрый доступ к элементам по индексу (O(1));

- доступ к элементам по значению за линейное время (O(n));

- реализации вставки и удаления элементов из "середины" списка - достаточно медленные и тяжелые;

- допускается хранение любых значений, в том числе и null (при этом null элементы и пустые ячейки разные вещи);

- размер списка это количество элементов в нем, а не размер внутреннего массива

