### LinkedList.

LinkedList - класс, который реализует два интерфейса - List и Deque. 
Этим обеспечивается возможность создавать двунаправленные(те, которые можно обходить в обоих направлениях) очереди 
из любых (в том числе и null) элементов. Каждый объект помещенный в связанный список, является узлом 
(для этого используются объекты вложенного класса Node). Каждый узел содержит в себе элемент который мы добавили, 
а также ссылку на предыдущий и следующий узел

    private static class Node<E> {
     E item;
     Node<E> next;
     Node<E> prev;

       Node(Node<E> prev, E element, Node<E> next) {
          this.item = element;
          this.next = next;
          this.prev = prev;
       }
     }
Выходит, что связанный список состоит из последовательных узлов, каждый из которых предназначен 
для хранения объекта определенного при создании типа.

Для создания экземпляра LinkedList в классе определено 2 конструктора:

1. *LinkedList ()* - создается пустой список.
2. *LinkedList (Collection<? extends E> col)* - создается список, в который помещается коллекция col.

#### Поля
1. *transient int size = 0;* - содержит в себе количество добавленных в список элементов
2. *transient Node<E> first;* - первый ужел в списке
3. *transient Node<E> last;* - последний узел в списке

####Добавление в конец списка 

    void linkLast(E e) {
       final Node<E> l = last;
       final Node<E> newNode = new Node<>(l, e, null);
       last = newNode;
       if (l == null) {
           first = newNode;
       }
       else {
           l.next = newNode;
       }
       size++;
       modCount++;
    }
Мы создаем новый узел l и присваиваем ему значение last, а затем на основании этого узла и нового элемента, 
который мы добавляем в список, создается узел newNode и полю last после этого присваивается значение newNode.

Если значение l равно null - то полю first присваивается значение newNode, 
иначе в поле next последнего узла Node будет записано значение newNode. 
Выходит, что при добавлении первого элемента в связанный список значения полей first и last - совпадают. 
И последнее - счетчик количества элементов увеличивается на 1.

####Добавление элемента по индексу. 
Сперва проверяется индекс переданный в метод - он должен быть неотрицательным, а также не превышать значение size, 
иначе будет выброшено исключение класса IndexOutOfBoundsException.

Далее выполняется проверка:

    if (index == size) {
       linkLast(element);
    }
при ее выполнении осуществляется добавление элемента согласно методу linkLast. 
Если же оно не выполнится, то в работу вступает метод **linkBefore(element, node(index))**

    void linkBefore(E e, Node<E> succ) {
       final Node<E> pred = succ.prev;
       final Node<E> newNode = new Node<>(pred, e, succ);
       succ.prev = newNode;
       if (pred == null)
           first = newNode;
       else
           pred.next = newNode;
       size++;
       modCount++;
    }
Мы получаем значение предыдущего узла, на его основании и добавляемого значения создается новый узел newNode() 
и в поле prev узла с индексом по которому мы добавляем записывается значение newNode.

Если окажется, что предыдущий узел равен null, то новый узел записывается в поле first.

Иначе, происходит так называемая "перелинковка" ссылок, когда в поле next предыдущего узла записывается новый узел newNode.

####Удаление элемента из связанного списка.

Удалять мы можем по индексу и по значению. В основе работы обоих методов лежит метод *E unlink(Node<E> x)*, 
различия лишь состоят в том, что удаление по значению предполагает поиск индекса удаляемого значения 
и только потом происходит удаление, которое заключается в уже упомянутой ранее "перелинковка" ссылок на узлы:

    E unlink(Node<E> x) {
      // assert x != null;
      final E element = x.item;
      final Node<E> next = x.next;
      final Node<E> prev = x.prev;

        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }

       x.item = null;
       size--;
       modCount++;
       return element;
    }
Сначала мы извлекаем узлы, а также значение которое будем удалять.
Далее выполняем ряд проверок, в зависимости от их результатов выполняем "перелинковки" - 
если предыдущий узел равен null - назначаем полю класса first значение next ранее извлеченного узла, 
иначе - в соответствующие поля записываем узел, а также зануляем поле prev удаляемого узла:

Похожее поведение определенно, когда проводится проверка, что следующий узел за удаляемым равен null:

После выполнения всех проверок происходит обнуление удаляемого значения и уменьшение счетчика size:

####Выводы по реализации LinkedList:

- Позволяет хранить любые данные, в том числе null и дубликаты.

- Обеспечивает быстрое (O(1)) добавление и удаление первого и последнего элемента. 
  Также быстро выполняются операции вставки и удаления элементов в середину списка(выносим за скобки поиск позиции элемента, 
  который осуществляется за линейное время).

- Поиск элемента по значению и индексу осуществляется за линейное время (O(n)).