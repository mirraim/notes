### HashSet.
Это коллекция, которая не позволяет хранить одинаковые объекты(как и любой Set). 
HashSet инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. 
При этом ключами в таблице будут значения которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - 
будут значения null.

Хэш-таблица хранит информацию, используя механизм хеширования, в котором содержимое ключа используется для определения 
уникального значения - хеш-код. Хеш-код используется в качестве индекса, с которым ассоциируются данные, которые доступны по ключу. 
Преобразование ключа в хеш-код и обратно выполняется автоматически - об этом будет рассказано позже при рассмотрении HashMap. 
Хеширование выгодно тем, что оно обеспечивает константное время выполнения методов contains(), add(), remove().

Для того, чтобы использовать HashSet для хранения объектов, описанных классами собственной реализации, необходимо 
переопределить методы hashcode() и equals(), иначе два логически одинаковых объекта будут считать разными.

Класс HashSet не гарантирует упорядоченности элементов, поскольку процесс хеширования не позволяет сделать в итоге 
отсортированный набор данных.

Для создания объекта HashSet в классе определены 4 конструктора:

1. *HashSet()* - создается пустое множество - при этом инкапсулированный объект HashMap имеет по умолчанию начальную емкость 
   16 элементов и коэффициент загрузки 0.75.

2. *HashSet(int initialCapacity)* - создается пустое множество - при этом объект HashMap, который используется внутри 
   будет иметь начальную емкость, переданную в конструктор, и коэффициент загрузки по умолчанию - 0.75.

3. *HashSet(int initialCapacity, float loadFactor)* - создается пустое множество - при этом объект HashMap, 
   который используется внутри будет иметь начальную емкость и коэффициент загрузки, которые передаются в конструктор.

4. *HashSet(Collection<? extends E> c)* - будет создано множество, в которое будет помещены элементы передаваемой коллекции.

