:адный алгоритм (greedy algorithm) — это алгоритм,
который на каждом шагу делает локально наилучший выбор в надежде,
что итоговое решение будет оптимальным.
К примеру, алгоритм Дейкстры нахождения кратчайшего пути в графе вполне себе жадный,
потому что мы на каждом шагу ищем вершину с наименьшим весом,
в которой мы еще не бывали, после чего обновляем значения других вершин.
При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.

К слову, алгоритм Флойда, который тоже ищет кратчайшие пути в графе (правда, между всеми вершинами),
не является примером жадного алгоритма.
Флойд демонстрирует другой метод — метод динамического программирования.

Жадные алгоритмы — жадные. Они не смотрят в будущее, чтобы выбрать глобальное оптимальное решение.
Их интересует только лучшее решение в данный момент.
Но общее оптимальное решение может отличаться от решения,
которое выбирает алгоритм на каждом шаге своей работы.
Так же они никогда не оглядываются назад на то, что сделали, чтобы понять,
нужна ли глобальная оптимизация.
В этом главное отличие жадного и динамического программирования.


Примеры популярных жадных алгоритмов:

Dijkstra’s Algorithm (Алгоритм Дейкстры)
Kruskal’s algorithm (Алгоритм Крускала)
Prim’s algorithm (Алгоритм Прима)
Huffman trees (Деревья Хаффмана)

 private static final int[] COINS = {10, 5, 2, 1};

    public int[] change(int money, int price) {
        int[] rsl = new int[100];
        int size = 0;
        int remain = money - price;
        for (int i = 0; i < COINS.length; i++) {
            while (remain - COINS[i] >= 0) {
                rsl[size] = COINS[i];
                remain -= COINS[i];
                size++;
            }
        }
    }