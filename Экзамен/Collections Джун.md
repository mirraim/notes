#### Дженерики 
 это параметризованные типы. 
 С их помощью можно объявлять классы, интерфейсы и методы, 
 где тип данных указан с помощью параметра
 Generics заключается в скобки <>. 
 Это означает, что конструкция работает только с элементами, 
 которые являются экземплярами класса, указанного в скобках. 
 При попытке добавить экземпляр другого класса будет ошибка компиляции.
#### Wildcard
<?> имеет соответствие с любым типом, а не тоько с теми, что унаследованы от Object
#### Bounded Wildcard
< ? extends T>  имеет ограничение сверху. Все классы, унаследованные от класса T
#### Lower bounded wcard
< ? super T>  имеет ограничение снизу. Все супертипы класса Т
#### Стирание типов
Во время компиляции происходит так называемое **стирание типов**. 
Это значит, что во время выполнения программы недоступна информация о типе-параметре.
Существует только одна ситуация, в которой можно получить тип во время выполнения программы - 
когда универсальный тип является частью сигнатуры класса.

    public static void main(String[] args) {
    ArrayList<Float> listOfNumbers = new FloatList();
    Class actual = listOfNumbers.getClass();
    ParameterizedType type = (ParameterizedType) actual.getGenericSuperclass();
    System.out.println(type);
    Class parameter = (Class) type.getActualTypeArguments()[0];
    System.out.println(parameter);
    }    

1. Создать экземпляр класса
2. Получить класс экземпляра
3. Получить параметризованный тип 
4. Получить класс параметризованного типа

#### Iterator - 
это поведенческий шаблон проектирования, который позволяет пройтись 
по всем элементам некоторого составного объекта. 
Одним из важных условий при реализации паттерная является то, 
что итератор должен гарантировать нераскрытие внутреннего устройства объекта.

####Коллекции (Collection Framework) – 
это хранилища, поддерживающие различные способы накопления 
и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним.

####Контракт equals
При переопределении метода equals разработчик должен придерживаться основных правил, определенных в спецификации языка Java.
- *Рефлексивность*
  для любого заданного значения x, выражение x.equals(x) должно возвращать true.
- *Симметричность* 
  для любых заданных значений x и y, x.equals(y) должно возвращать true только в том случае, когда y.equals(x) возвращает true.
- *Транзитивность*
  для любых заданных значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, x.equals(z) должно 
  вернуть значение true.
- *Согласованность*
  для любых заданных значений x и y повторный вызов x.equals(y) будет возвращать значение предыдущего вызова этого метода 
  при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.


####Контракт hashCode
Для реализации хэш-функции в спецификации языка определены следующие правила:
1. вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, 
   при условии что поля объекта, участвующие в вычислении значения, не изменялись.
2. вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, 
   если эти объекты равны (вызов метода equals для этих объектов возвращает true).
3. вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. 
   Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность 
   работы хэш-таблиц.


####Асимптотический анализ алгоритмов
Анализ сравнения затрат времени алгоритмов, выполняемых решение экземпляра некоторой задачи, при больших объемах входных данных, 
называется *асимптотическим*. Алгоритм, имеющий меньшую асимптотическую сложность, является наиболее эффективным.

В асимптотическом анализе, сложность алгоритма – это функция, позволяющая определить, 
как быстро увеличивается время работы алгоритма с увеличением объёма данных.

Основные оценки роста, встречающиеся в асимптотическом анализе:

- Ο (О-большое) – верхняя асимптотическая оценка роста временной функции;
- Ω (Омега) – нижняя асимптотическая оценка роста временной функции;
- Θ (Тета) – нижняя и верхняя асимптотические оценки роста временной функции.


Подсчет количества операций – дело утомительное и, что важно, совсем не обязательное. 
Исходя из выше перечисленных правил, чтобы определить сложность алгоритма, не нужно, как мы это делали прежде, 
считать все операции, достаточно знать какой сложностью обладает та или иная конструкция алгоритма (оператор или группа операторов). 
Так, алгоритм, не содержащий циклов и рекурсий, имеет константную сложность O(1). Сложность цикла, выполняющего n итераций, равна O(n).
Конструкция их двух вложенных циклов, зависящих от одной и той же переменной n, имеет квадратичную сложность O(n2).

Вот наиболее часто встречающиеся классы сложности:

- O(1) – константная сложность;
- О(n) – линейная сложность;
- О(nа) – полиномиальная сложность;
- О(Log(n)) – логарифмическая сложность;
- O(n*log(n)) – квазилинейная сложность;
- O(2^n) – экспоненциальная сложность;
- O(n!) – факториальная сложность.

#### Деревья
Поиск в отсортированном массиве происходит за время O(log(n)). Вставка нового элемент в начало за время O(n).

Поиск в связанном списке занимает время O(n), вставка элемента в начало/конец за время O(1).
Деревья объединяют преимущество связанных списков и отсортированных массивов.
В Java используются красно-черные деревья бинарного поиска -  RB Tree.

Базовый элемент дерева - это узел. Узел хранит в себе данные и ссылки на другие узлы. 
Родительский узел может иметь от 0 до N потомков. В случае с бинарным деревом родительский узел может иметь от 0 до 2 потоком.

В деревьях не могут быть циклических связей. В узел можно прийти только единственным путем.

Родительский узел имеет левый и правый узел, которые могут быть null ссылками.

Чтобы бинарное дерево стало бинарным деревом поиска нужно выполнить правило:
1. Значение левого потомка должно быть меньше или равно родительскому. 
2. Значение правого потомка должно быть больше или равно родительскому.
